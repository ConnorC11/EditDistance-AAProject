uni = []
def med_recursive(s1, s2):
    n = len(s1)
    m = len(s2)
    # base cases
    if n == 0 and m == 0:
        return 0
    if n == 0:
        return m
    if m == 0:
        return n
    # recursive definition
    con1 = med_recursive(s1[:-1], s2) + 1   # Deletion
    con2 = med_recursive(s1, s2[:-1]) + 1   # Insertion
    con3 = med_recursive(s1[:-1], s2[:-1]) + (s1[-1] != s2[-1])   # Substitution
    global uni
    if min(con1, con2, con3) == con1:
        uni.append('D')
    elif min(con1, con2, con3) == con2:
        uni.append('I')
    else:
        uni.append('S')
    return min(con1, con2, con3)
s1="ertian"
s2="cutionan"
    # create the alignment\
ss = ""
tt = ""
mark = ""
def alignment_pure(s1,s2):
    i = len(s1) + 1
    j = len(s2) + 1
    val = med_recursive(s1, s2)
    ck = i - j
    ck2 = j - i
    global ss
    global tt
    global mark
    if i == j :
        for k in range(1,min(i,j)):
            if uni[-k] == 'I':
                ss += s1[k - 1] + ' '
                tt += '-' + ' '
                mark += ' ' + ' '
            elif uni[-k] == 'S':
                ss += s1[k - 1] + ' '
                tt += s2[k - 1] + ' '
                if s1[k - 1] == s2[k - 1]:
                    mark += '|' + ' '
                else:
                    mark += ' ' + ' '
            else:
                ss += '-' + ' '
                tt += s2[k - 1] + ' '
                mark += ' ' + ' '
        return
    if i > j :
        alignment_pure(s1[:-ck],s2)
        while not ck == 0:
            tt += '-' + ' '
            mark += ' ' + ' '
            ss += s1[-ck] + ' '
            ck = ck - 1
        return ss, mark, tt
    if j > i :
        alignment_pure(s1, s2[:-ck2])
        while not ck2 == 0 :
            ss += '-' + ' '
            mark += ' ' + ' '
            tt += s2[-ck2] + ' '
            ck2 = ck2 - 1
        return ss,mark,tt
    print(ss)
    print(mark)
    print(tt)
    return
print(alignment_pure(s1,s2))
print(med_recursive(s1,s2))
print(ss)
print(mark)
print(tt)
