
uni = []
def med_recursive(s1, s2):
    n = len(s1)
    m = len(s2)
    # base cases
    if n == 0 and m == 0:
        return 0
    if n == 0:
        return m
    if m == 0:
        return n
    # recursive definition

    # mcon = []
    con1 = med_recursive(s1[:-1], s2) + 1   # Deletion
    # mcon.append(con1)
    con2 = med_recursive(s1, s2[:-1]) + 1   # Insertion
    # mcon.append(con2)
    con3 = med_recursive(s1[:-1], s2[:-1]) + (s1[-1] != s2[-1])   # Substitution

    global uni

    if min(con1, con2, con3) == con1:
        uni.append('D')
    elif min(con1, con2, con3) == con2:
        uni.append('I')
    else:
        uni.append('S')
    return min(con1, con2, con3)

s1="ertion"
s2="cution"

    # create the alignment\

def alignment_pure(s1,s2):

    ss = ""
    tt = ""
    mark = ""

    i = len(s1) + 1
    j = len(s2) + 1

    val = med_recursive(s1, s2)

    for k in range(1,max(i,j)):
        if uni[-k] == 'I':
            ss += s1[k - 1] + ' '
            tt += '-' + ' '
            mark += ' ' + ' '
            k = k - 1
        elif uni[-k] == 'S':
            ss += s1[k - 1] + ' '
            tt += s2[k - 1] + ' '
            if s1[k - 1] == s2[k - 1]:
                mark += '|' + ' '
            else:
                mark += ' ' + ' '
            k = k - 1
        else:
            ss += '-' + ' '
            tt += s2[k - 2] + ' '
            mark += ' ' + ' '
            j = j - 1

    print(ss)
    print(mark)
    print(tt)

    return
